# geth 的账户状态存储模型

本文系统讲解 **geth（Ethereum 执行层客户端）** 的账户状态存储模型，从逻辑结构到源码实现，涵盖：  
世界状态、账户模型、State Trie、Storage Trie、落盘方式、StateDB 与状态提交流程。

---

## 一、世界状态（World State）

在任意区块高度，以太坊都有一个唯一的 **世界状态**：

```
WorldState : Address → Account
```

在 geth 中，该映射通过 **Merkle Patricia Trie（MPT）** 表示，其根哈希存储在区块头中：

```
BlockHeader.StateRoot
```

只要账户状态发生变化，`StateRoot` 就会发生变化，这是状态可验证性的基础。

---

## 二、账户模型（Account Object）

### 1. 账户结构

```go
type Account struct {
    Nonce    uint64
    Balance  *big.Int
    Root     common.Hash // storage trie root
    CodeHash []byte
}
```

字段含义：

| 字段 | 含义 |
|---|---|
| Nonce | 交易序号 / 合约创建计数 |
| Balance | 账户余额 |
| Root | 合约存储 Trie 根 |
| CodeHash | 合约代码哈希 |

---

### 2. EOA 与合约账户差异

| 类型 | Root | CodeHash |
|---|---|---|
| EOA | 空 Trie Root | keccak256("") |
| 合约账户 | Storage Trie Root | keccak256(code) |

---

## 三、State Trie（账户 Trie）

### 1. Trie 结构

- 类型：Modified Merkle Patricia Trie  
- key：`keccak256(address)`  
- value：`RLP(Account)`  

```
StateTrie
 ├── keccak(addr1) → RLP(Account1)
 ├── keccak(addr2) → RLP(Account2)
 └── ...
```

使用哈希地址作为 key 可避免 Trie 退化并提升安全性。

---

### 2. StateRoot 的作用

```
StateRoot = MPT.rootHash(StateTrie)
```

StateRoot 是整个世界状态的加密承诺（cryptographic commitment）。

---

## 四、合约存储模型（Storage Trie）

### 1. Storage Trie 结构

每个合约账户内部都有一棵 Storage Trie：

- key：`keccak256(slot)`  
- value：`RLP(value)`  

```
Account.Root → StorageTrie
```

slot 来源于 Solidity 的 storage layout。

---

### 2. 嵌套结构关系

```
Block
 └── StateRoot
     └── StateTrie
         └── Account
             └── StorageRoot
                 └── StorageTrie
```

---

## 五、物理存储（geth 如何落盘）

### 1. 底层数据库

- 旧版本：LevelDB  
- 新版本：Pebble  

默认路径：

```
~/.ethereum/geth/chaindata/
```

---

### 2. Trie Node 的存储方式

```
Key   = keccak256(rlp(node))
Value = rlp(node)
```

这是 **内容寻址存储（CAS）**：

- 相同节点只存一次
- 多个 Trie 可共享子树

geth **不会直接存 address → Account 映射**，只存 Trie Node。

---

## 六、StateDB：状态管理层

### 1. StateDB 的职责

```go
type StateDB struct {
    db   Database
    trie Trie
    stateObjects map[Address]*stateObject
}
```

StateDB 是执行层的：

- 状态缓存
- 事务管理器
- 回滚支持系统

---

### 2. 状态修改流程

交易执行时：

1. 从 Trie 读取账户
2. 构建 stateObject
3. 修改余额 / storage / nonce
4. 标记为 dirty（未落盘）

---

### 3. Commit 阶段

```go
stateDB.Commit(blockNumber, ...)
```

执行：

- 写入 Storage Trie
- 更新 Account
- 更新 State Trie
- 生成新的 StateRoot
- 落盘到数据库

---

## 七、交易执行与状态流转

```
Transaction
 ↓
EVM 执行
 ↓
StateDB 修改
 ↓
stateObject dirty
 ↓
区块执行完成
 ↓
StateDB.Commit()
 ↓
生成新的 StateRoot
 ↓
写入 DB
```

在区块最终确认前，状态可能因 reorg 被回滚。

---

## 八、Snapshot（快照机制）

### 1. Snapshot 是什么

Snapshot 是 State Trie 的扁平视图：

```
address → account
address + slot → value
```

存储路径：

```
chaindata/snapshots/
```

---

### 2. Snapshot 的特点

- 用于性能优化
- 非共识数据
- 可删除 / 可重建

---

## 九、总结

**geth 的账户状态存储模型本质是：**

- 世界状态是一棵 MPT  
- 账户是 Trie 中的 value  
- 合约存储是账户下的子 Trie  
- StateDB 提供事务化状态管理  
- StateRoot 锚定进区块头，实现全网可验证  

---

如果继续深入，可以进一步阅读：

- `core/state/statedb.go`
- `core/state/state_object.go`
- `trie/` 目录实现
